Проект: Управление двухзвенным маятником с помощью обратного якобиана в PyBullet

# Обзор

Проект реализует перемещение двухзвенного маятника в заданное декартово положение с использованием встроенной функции вычисления обратного якобиана в PyBullet. Управление осуществляется путем задания целевой позиции для манипулятора, а PyBullet рассчитывает необходимые углы сочленений с помощью метода обратной кинематики.

Реализовано в рамках изучения численных методов и симуляции физических процессов с применением библиотеки PyBullet.

# Задача

Обеспечить переход двухзвенного маятника в заданную декартову позицию за счёт вычисления обратного якобиана средствами PyBullet и управления положением звеньев.

# Математическая модель

Система состоит из двух звеньев, соединенных шарнирами. Управление происходит через задание целевого положения для конечного эффектора:

* Описание звеньев и сочленений реализовано в URDF-модели.
* PyBullet предоставляет API для расчета якобиана и его обратной матрицы для определения необходимых углов сочленений.

## Обратная кинематика

PyBullet предоставляет функцию `calculateInverseKinematics`, которая под капотом использует якобиан и оптимизационные методы для вычисления требуемых углов:

```python
joint_angles = p.calculateInverseKinematics(
    bodyUniqueId=robot_id,
    endEffectorLinkIndex=link_index,
    targetPosition=target_position,
    targetOrientation=target_orientation)
```

# Реализация

* **Симуляция**: используется физический движок PyBullet.
* **Модель**: URDF-файл описывает двухзвенный маятник.
* **Управление**: задается целевая точка в декартовом пространстве, затем PyBullet рассчитывает требуемые углы.
* **Применение управления**: рассчитанные углы применяются через API `setJointMotorControl2` в режиме `POSITION_CONTROL`.
* **Визуализация**: через встроенный GUI в PyBullet.

## Структура проекта

* `main.py`: основной цикл симуляции, вычисление ИК и управление.
* `robot.urdf`: URDF-модель двухзвенного маятника.
* `utils.py`: вспомогательные функции (визуализация, логирование).
* `config.py`: параметры симуляции (время шага, целевая позиция и т.п.).
* `README.md`: описание проекта и анализа.

# Установка и запуск

Установите зависимости:

```bash
pip install pybullet numpy
```

Запустите симуляцию:

```bash
python main.py
```

Убедитесь, что `robot.urdf` находится в том же каталоге.

# Как это работает

1. **Инициализация**: загружается модель маятника и плоскости.
2. **Целевая позиция**: в `config.py` задается декартова точка для конечного эффектора.
3. **Обратная кинематика**: в `main.py` вызывается `calculateInverseKinematics` для расчета требуемых углов.
4. **Применение углов**: значения подаются на сочленения с помощью `setJointMotorControl2`.
5. **Симуляция**: PyBullet выполняет шаги симуляции и визуализирует движение.

# Анализ результатов

* **Точность**: маятник точно достигает заданной точки (в пределах численной погрешности).
* **Скорость**: переход к точке занимает менее 1 секунды при стандартных параметрах симуляции.
* **Стабильность**: PyBullet обеспечивает плавное и устойчивое движение за счёт симуляции физики.

# Примечания

* Для нестандартных URDF или конфигураций манипулятора могут потребоваться дополнительные параметры в `calculateInverseKinematics` (например, ограничения сочленений или приоритет ориентации).
* При необходимости обеспечить ориентацию конечного эффектора можно задать `targetOrientation`.

# Возможные улучшения

* Добавление управления с обратной связью (например, PID по положению).
* Реализация движения по траектории.
* Сравнение аналитического и численного расчета ИК.

# Автор

Реализовано в рамках изучения симуляции в PyBullet.
